import { createFilter } from '@rollup/pluginutils';
import path from 'path';
import stylexBabelPlugin from '@stylexjs/babel-plugin';
import { parseSync, transformAsync } from '@babel/core';
import fs from 'fs';
import _stylexExtendBabelPlugin from '@stylex-extend/babel-plugin';

function unique(data) {
    return Array.from(new Set(data));
}
function error(message) {
    throw new Error(`[vite-plugin-stylex-dev]: ${message}`);
}
function hijackHook(plugin, name, next, executable = false) {
    if (!plugin[name]) throw error(`'${name}' haven't implement yet.`);
    const hook = plugin[name];
    if ('handler' in hook) {
        const fn = hook.handler;
        hook.handler = function handler(...args) {
            return next(fn, this, args);
        };
        if (executable) return hook.handler;
    } else {
        const fn = hook;
        plugin[name] = function handler(...args) {
            return next(fn, this, args);
        };
        if (executable) return plugin[name];
    }
}
// MIT License
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
function slash(path) {
    const isExtendedLengthPath = /^\\\\\?\\/.test(path);
    if (isExtendedLengthPath) return path;
    return path.replace(/\\/g, '/');
}
function hasPackageJSON(root) {
    const s = path.join(root, 'package.json');
    return fs.existsSync(s);
}
/**
 * Search up for the nearest `package.json`
 */ function searchForPackageRoot(current, root = current) {
    if (hasPackageJSON(current)) return current;
    const dir = path.dirname(current);
    // reach the fs root
    if (!dir || dir === current) return root;
    return searchForPackageRoot(dir, root);
}
function hash(str) {
    let i;
    let l;
    let hval = 0x811C9DC5;
    for(i = 0, l = str.length; i < l; i++){
        hval ^= str.charCodeAt(i);
        hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
    }
    return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}

const CONSTANTS = {
    WS_EVENT: 'stylex:hmr',
    VIRTUAL_STYLEX_ID: 'virtual:stylex.css',
    RESOLVED_ID_WITH_QUERY_REG: /[/\\]__stylex(_.*?)?\.css(\?.*)?$/,
    RESOLVED_ID_REG: /[/\\]__stylex(?:_(.*?))?\.css$/,
    VIRTUAL_ENTRY_ALIAS: [
        /^(?:virtual:)?stylex(?::(.+))?\.css(\?.*)?$/
    ],
    STYLEX_BUNDLE_MARK: '@stylex__bundle__marker;',
    HASH_LENGTH: 6,
    CSS_PLUGINS: [
        'vite:css',
        'vite:css-post'
    ],
    WELL_KNOW_LIBRARIES: [
        '@stylexjs/open-props'
    ]
};
function resolveId(id) {
    if (id.match(CONSTANTS.RESOLVED_ID_WITH_QUERY_REG)) {
        return id;
    }
    for (const alias of CONSTANTS.VIRTUAL_ENTRY_ALIAS){
        const matched = id.match(alias);
        if (matched) {
            return '/__stylex.css';
        }
    }
}
let hmr = `
try {
  let hash = __vite__css.match(/__stylex_hash_(\\w{${CONSTANTS.HASH_LENGTH}})/)
  hash = hash && hash[1]
  if (!hash) {
   console.log('[vite-plugin-stylex]', 'Failed to get stylex hash, hmr might not work!')
  } else {
    await import.meta.hot.send('${CONSTANTS.WS_EVENT}', hash)
  }

} catch (e) {
  console.warn('[vite-plugin0-stylex]', e)
}
if (!import.meta.url.include('?')) {
   await new Promise(r => setTimeout(r, 100))
}
`;
hmr = `\nif (import.meta.hot) { ${hmr} }`;
function stylexServer(plugin, ctx, cssPlugins, conf) {
    const cssHooks = new Map();
    let viteDevServer = null;
    let lastServerTime = Date.now();
    const modules = new Set();
    const generateCSS = ()=>{
        let css = '';
        const expect = modules.size;
        for(;;){
            css = ctx.produceCSS();
            if (expect === ctx.styleRules.size) {
                break;
            }
        }
        lastServerTime = Date.now();
        return {
            css,
            hash: hash(css)
        };
    };
    const update = (ids)=>{
        if (!viteDevServer) return;
        viteDevServer.ws.send({
            type: 'update',
            updates: Array.from(ids).map((id)=>{
                const mod = viteDevServer === null || viteDevServer === void 0 ? void 0 : viteDevServer.moduleGraph.getModuleById(id);
                if (!mod) return null;
                return {
                    acceptedPath: id,
                    path: mod.url,
                    timestamp: lastServerTime,
                    type: 'js-update'
                };
            }).filter((s)=>s !== null)
        });
    };
    let invalidateTimer;
    const invalidate = (ids)=>{
        for (const id of ids){
            const mod = viteDevServer === null || viteDevServer === void 0 ? void 0 : viteDevServer.moduleGraph.getModuleById(id);
            if (!mod) continue;
            viteDevServer === null || viteDevServer === void 0 ? void 0 : viteDevServer.moduleGraph.invalidateModule(mod);
        }
        clearTimeout(invalidateTimer);
        invalidateTimer = setTimeout(()=>{
            update(ids);
        }, 10);
    };
    const entries = new Set();
    const schedule = {
        enforce: 'pre',
        name: 'stylex:server',
        apply: 'serve',
        resolveId (id) {
            const entry = resolveId(id);
            if (entry) {
                entries.add(entry);
                return entry;
            }
        },
        load (id) {
            const { original } = parseRequest(id);
            const matched = original.match(CONSTANTS.RESOLVED_ID_REG);
            if (matched) {
                const { hash, css } = generateCSS();
                return {
                    code: `${css}__stylex_hash_${hash}{--:'';}`,
                    map: {
                        mappings: ''
                    }
                };
            } else {
                if (ctx.isManuallyControlCSS && original === ctx.controlCSSByManually.id) {
                    entries.add(id);
                }
            }
        },
        configureServer (server) {
            viteDevServer = server;
            viteDevServer.ws.on(CONSTANTS.WS_EVENT, ()=>{
                update(entries);
            });
        }
    };
    const pos = conf.plugins.findIndex((p)=>p.name === 'stylex');
    // @ts-expect-error
    conf.plugins.splice(pos, 0, schedule);
    //
    hijackHook(plugin, 'transform', async (fn, c, args)=>{
        const id = args[1];
        const { original } = parseRequest(id);
        const result = await fn.apply(c, args);
        if (ctx.styleRules.has(original)) {
            // record affect module.
            modules.add(original);
            invalidate(new Set([
                ...entries,
                ...modules
            ]));
        }
        if (ctx.isManuallyControlCSS && ctx.controlCSSByManually.id === original) {
            var _cssHooks_get;
            //  FIXME
            // Find a better way pipe to vite's internal processer
            if (!cssHooks.size) {
                cssPlugins.forEach((p)=>{
                    cssHooks.set(p.name, hijackHook(p, 'transform', (fn, c, args)=>fn.apply(c, args), true));
                });
            }
            const css = fs.readFileSync(ctx.controlCSSByManually.id, 'utf8').replace(ctx.controlCSSByManually.symbol, generateCSS().css);
            return (_cssHooks_get = cssHooks.get('vite:css')) === null || _cssHooks_get === void 0 ? void 0 : _cssHooks_get.apply(c, [
                css,
                id,
                args[2]
            ]);
        }
        if (original.match(CONSTANTS.RESOLVED_ID_REG) && args[0].includes('import.meta.hot')) {
            const code = args[0] + hmr;
            return {
                code,
                map: {
                    mappings: ''
                }
            };
        }
        return result;
    });
}

function _check_private_redeclaration(obj, privateCollection) {
    if (privateCollection.has(obj)) {
        throw new TypeError("Cannot initialize the same private elements twice on an object");
    }
}
function _class_apply_descriptor_get(receiver, descriptor) {
    if (descriptor.get) {
        return descriptor.get.call(receiver);
    }
    return descriptor.value;
}
function _class_apply_descriptor_set(receiver, descriptor, value) {
    if (descriptor.set) {
        descriptor.set.call(receiver, value);
    } else {
        if (!descriptor.writable) {
            throw new TypeError("attempted to set read only private field");
        }
        descriptor.value = value;
    }
}
function _class_extract_field_descriptor(receiver, privateMap, action) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to " + action + " private field on non-instance");
    }
    return privateMap.get(receiver);
}
function _class_private_field_get(receiver, privateMap) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "get");
    return _class_apply_descriptor_get(receiver, descriptor);
}
function _class_private_field_init(obj, privateMap, value) {
    _check_private_redeclaration(obj, privateMap);
    privateMap.set(obj, value);
}
function _class_private_field_set(receiver, privateMap, value) {
    var descriptor = _class_extract_field_descriptor(receiver, privateMap, "set");
    _class_apply_descriptor_set(receiver, descriptor, value);
    return value;
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
const defaultControlCSSOptions = {
    id: 'stylex.css',
    symbol: '@stylex-dev;'
};
const defaultStylexExtendOptions = {
    enableInjectGlobalStyle: true,
    stylex: {
        helper: 'props'
    }
};
function handleRelativePath(from, to) {
    const relativePath = path.relative(path.dirname(from), to).replace(/\.\w+$/, '');
    return `./${slash(relativePath)}`;
}
function scanImportStmt(code, filename, parserOptions) {
    const ast = parseSync(code, {
        parserOpts: {
            plugins: (parserOptions === null || parserOptions === void 0 ? void 0 : parserOptions.plugins) || []
        },
        babelrc: false,
        filename
    });
    const stmts = [];
    for (const n of ast.program.body){
        if (n.type === 'ImportDeclaration') {
            const v = n.source.value;
            if (!v) continue;
            const { start: s, end: e } = n.source;
            if (typeof s === 'number' && typeof e === 'number') {
                stmts.push({
                    n: v,
                    s: s + 1,
                    e: e - 1
                });
            }
        }
    }
    return stmts;
}
function parseRequest(id) {
    const [original, kind] = id.split('?');
    if (!kind) return {
        original,
        kind: 'native'
    };
    return {
        original,
        kind
    };
}
var _pluginOptions = /*#__PURE__*/ new WeakMap(), _env = /*#__PURE__*/ new WeakMap(), _rollupPluginContext = /*#__PURE__*/ new WeakMap(), _stmts = /*#__PURE__*/ new WeakMap();
class PluginContext {
    get filter() {
        return createFilter(_class_private_field_get(this, _pluginOptions).include, _class_private_field_get(this, _pluginOptions).exclude);
    }
    get stylexExtendOptions() {
        const { enableStylexExtend } = _class_private_field_get(this, _pluginOptions);
        if (typeof enableStylexExtend === 'boolean' && enableStylexExtend) {
            return {
                ...defaultStylexExtendOptions
            };
        }
        if (typeof enableStylexExtend === 'object') {
            if (!enableStylexExtend) return {};
            return {
                ...defaultStylexExtendOptions,
                ...enableStylexExtend
            };
        }
        return {};
    }
    get stylexOptions() {
        return _class_private_field_get(this, _pluginOptions);
    }
    setupRollupPluginContext(rollupPluginContext) {
        if (_class_private_field_get(this, _rollupPluginContext)) return;
        _class_private_field_set(this, _rollupPluginContext, rollupPluginContext);
    }
    skipResolve(code, id) {
        if (!this.filter(id) || id.startsWith('\0')) return false;
        const { kind } = parseRequest(id);
        if (kind.includes('.css')) return false;
        _class_private_field_set(this, _stmts, scanImportStmt(code, id));
        let pass = false;
        for (const stmt of _class_private_field_get(this, _stmts)){
            const { n } = stmt;
            if (n && this.importSources.some((i)=>!path.isAbsolute(n) && n.includes(typeof i === 'string' ? i : i.from))) {
                pass = true;
            }
        }
        return pass;
    }
    // Alough stylex/stylex-extend support translate path aliases to relative path
    // But it only supports tsconfig-style aliases. Now we have parsed the import stmt
    // So why not transform them to relative path directly?
    async rewriteImportStmts(code, id, stmts = _class_private_field_get(this, _stmts)) {
        let byteOffset = 0;
        for (const stmt of stmts){
            if (!stmt.n) continue;
            if (path.isAbsolute(stmt.n) || stmt.n[0] === '.') continue;
            if (!this.importSources.some((i)=>stmt.n.includes(typeof i === 'string' ? i : i.from))) continue;
            const resolved = await _class_private_field_get(this, _rollupPluginContext).resolve(stmt.n, id);
            if (resolved && resolved.id && !resolved.external) {
                if (resolved.id === stmt.n) continue;
                if (CONSTANTS.RESOLVED_ID_REG.test(resolved.id)) continue;
                if (!resolved.id.includes('node_modules')) {
                    const next = handleRelativePath(id, resolved.id);
                    const start = stmt.s + byteOffset;
                    const end = stmt.e + byteOffset;
                    code = code.substring(0, start) + next + code.substring(end);
                    byteOffset += next.length - (stmt.e - stmt.s);
                }
            }
        }
        _class_private_field_set(this, _stmts, []);
        return code;
    }
    produceCSS(input = this.styleRules) {
        if (!input.size) return '';
        const { useCSSLayers } = this.stylexOptions;
        return stylexBabelPlugin.processStylexRules([
            ...input.values()
        ].flat().filter(Boolean), useCSSLayers) + '\n' + Object.values(this.globalStyles).join('\n');
    }
    destory() {
        this.styleRules.clear();
        this.root = process.cwd();
        this.globalStyles = {};
        _class_private_field_set(this, _rollupPluginContext, null);
    }
    // We don't recommend using NODE_ENV to determine the environment type.
    // Instead, we recommend using a custom environment variable.
    // If their are any reports about this. we can add a note to the docs.
    get env() {
        return _class_private_field_get(this, _env);
    }
    set env(env) {
        _class_private_field_set(this, _env, env);
    }
    get importSources() {
        if (!_class_private_field_get(this, _pluginOptions).importSources) throw error('Missing "importSources" in options');
        return _class_private_field_get(this, _pluginOptions).importSources;
    }
    get stmts() {
        return _class_private_field_get(this, _stmts);
    }
    get rollupPluginContext() {
        return _class_private_field_get(this, _rollupPluginContext);
    }
    get controlCSSByManually() {
        const { manuallyControlCssOrder } = this.stylexOptions;
        let opt = {};
        if (typeof manuallyControlCssOrder === 'boolean' && manuallyControlCssOrder) {
            opt = {
                ...defaultControlCSSOptions
            };
        }
        if (typeof manuallyControlCssOrder === 'object' && manuallyControlCssOrder) {
            opt = {
                ...defaultControlCSSOptions,
                ...manuallyControlCssOrder
            };
        }
        if ('id' in opt) {
            opt.id = slash(opt.id);
        }
        return opt;
    }
    get isManuallyControlCSS() {
        return !!this.controlCSSByManually.id;
    }
    constructor(options){
        _define_property(this, "styleRules", void 0);
        _define_property(this, "globalStyles", void 0);
        _class_private_field_init(this, _pluginOptions, {
            writable: true,
            value: void 0
        });
        _define_property(this, "root", void 0);
        _class_private_field_init(this, _env, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _rollupPluginContext, {
            writable: true,
            value: void 0
        });
        _class_private_field_init(this, _stmts, {
            writable: true,
            value: void 0
        });
        this.styleRules = new Map();
        _class_private_field_set(this, _rollupPluginContext, null);
        _class_private_field_set(this, _pluginOptions, options);
        _class_private_field_set(this, _stmts, []);
        this.globalStyles = {};
        this.root = process.cwd();
        _class_private_field_set(this, _env, process.env.NODE_ENV === 'production' ? 'build' : 'server');
    }
}
function createPluginContext(options) {
    return new PluginContext(options);
}

function interopDefault(m) {
    return m.default || m;
}
const stylexExtendBabelPlugin = interopDefault(_stylexExtendBabelPlugin);
async function transformStylex(code, { filename, options, env }) {
    const { babelConfig, importSources } = options;
    return transformAsync(code, {
        babelrc: false,
        filename,
        presets: [],
        plugins: [
            ...(babelConfig === null || babelConfig === void 0 ? void 0 : babelConfig.plugins) || [],
            stylexBabelPlugin.withOptions({
                ...options,
                dev: env === 'server',
                runtimeInjection: false,
                importSources
            })
        ]
    });
}
function transformStylexExtend(code, { filename, options }) {
    const { opts, parserOptions } = options;
    return transformAsync(code, {
        plugins: [
            stylexExtendBabelPlugin.withOptions(opts)
        ],
        parserOpts: {
            plugins: parserOptions
        },
        babelrc: false,
        filename
    });
}

// This implement is a relatively stable version.
function stylexBuild(plugin, ctx, cssPlugins) {
    const cssHooks = new Map();
    const entries = new Set();
    const self = {
        enforce: 'post',
        resolveId (id) {
            const entry = resolveId(id);
            if (entry) {
                entries.add(entry);
                return entry;
            }
        },
        load (id) {
            const { original } = parseRequest(id);
            const matched = original.match(CONSTANTS.RESOLVED_ID_REG);
            if (matched) {
                return CONSTANTS.STYLEX_BUNDLE_MARK;
            } else {
                if (ctx.isManuallyControlCSS && original === ctx.controlCSSByManually.id) {
                    entries.add(id);
                    return CONSTANTS.STYLEX_BUNDLE_MARK;
                }
            }
        },
        renderChunk: {
            // By declare order we can get better performance for generate styles.
            async handler (_, chunk) {
                if (!cssHooks.size) {
                    cssPlugins.forEach((p)=>{
                        cssHooks.set(p.name, hijackHook(p, 'transform', (fn, c, args)=>fn.apply(c, args), true));
                    });
                }
                if (!chunk.moduleIds.some((s)=>entries.has(s))) {
                    return null;
                }
                for (const entry of [
                    ...entries
                ]){
                    var _cssHooks_get, _cssHooks_get1;
                    let css = ctx.produceCSS();
                    if (!CONSTANTS.RESOLVED_ID_REG.test(entry) && ctx.isManuallyControlCSS) {
                        const { original } = parseRequest(entry);
                        css = ctx.isManuallyControlCSS ? fs.readFileSync(original, 'utf8').replace(ctx.controlCSSByManually.symbol, css) : css;
                    }
                    const res = await ((_cssHooks_get = cssHooks.get('vite:css')) === null || _cssHooks_get === void 0 ? void 0 : _cssHooks_get.apply(ctx.rollupPluginContext, [
                        css,
                        entry
                    ]));
                    // @ts-expect-error
                    await ((_cssHooks_get1 = cssHooks.get('vite:css-post')) === null || _cssHooks_get1 === void 0 ? void 0 : _cssHooks_get1.apply(ctx.rollupPluginContext, [
                        (res === null || res === void 0 ? void 0 : res.code) || '',
                        entry
                    ]));
                    chunk.modules[entry] = {
                        code: null,
                        originalLength: 0,
                        removedExports: [],
                        renderedExports: [],
                        renderedLength: 0
                    };
                }
                return null;
            },
            order: 'pre'
        }
    };
    Object.assign(plugin, self);
}

function createForViteServer(ctx, extend) {
    const cssPlugins = [];
    return (plugin)=>{
        plugin.configResolved = function configResolved(conf) {
            var _ctx_stylexOptions_useCSSLayers;
            const adapterContext = {
                // eslint-disable-next-line prefer-spread
                produceCSS: (...rest)=>ctx.produceCSS.apply(ctx, rest),
                transform: plugin.transform,
                vite: {
                    cssPlugins,
                    config: conf
                },
                env: ctx.env,
                rules: ctx.styleRules,
                useCSSLayers: (_ctx_stylexOptions_useCSSLayers = ctx.stylexOptions.useCSSLayers) !== null && _ctx_stylexOptions_useCSSLayers !== void 0 ? _ctx_stylexOptions_useCSSLayers : false
            };
            ctx.env = conf.command === 'serve' ? 'server' : 'build';
            ctx.root = searchForPackageRoot(conf.root);
            const { importSources, stylexOptions } = ctx;
            if (!stylexOptions.unstable_moduleResolution) {
                stylexOptions.unstable_moduleResolution = {
                    type: 'commonJS',
                    rootDir: ctx.root
                };
            }
            const optimizedDeps = unique([
                ...Array.isArray(ctx.stylexOptions.optimizedDeps) ? ctx.stylexOptions.optimizedDeps : [],
                ...importSources.map((s)=>typeof s === 'object' ? s.from : s),
                ...CONSTANTS.WELL_KNOW_LIBRARIES
            ]);
            if (ctx.env === 'server') {
                var _conf_optimizeDeps_exclude;
                conf.optimizeDeps.exclude = [
                    ...optimizedDeps,
                    ...(_conf_optimizeDeps_exclude = conf.optimizeDeps.exclude) !== null && _conf_optimizeDeps_exclude !== void 0 ? _conf_optimizeDeps_exclude : []
                ];
            }
            if (conf.appType === 'custom') {
                conf.ssr.noExternal = Array.isArray(conf.ssr.noExternal) ? [
                    ...conf.ssr.noExternal,
                    ...optimizedDeps
                ] : conf.ssr.noExternal;
            }
            cssPlugins.push(...conf.plugins.filter((p)=>CONSTANTS.CSS_PLUGINS.includes(p.name)));
            cssPlugins.sort((a, b)=>a.name.length < b.name.length ? -1 : 1);
            const pos = conf.plugins.findIndex((p)=>p.name === 'stylex');
            if (Object.keys(ctx.stylexExtendOptions).length) {
                // @ts-expect-error
                conf.plugins.splice(pos, 0, extend(ctx));
            }
            ctx.env === 'build' ? stylexBuild(plugin, ctx, cssPlugins) : stylexServer(plugin, ctx, cssPlugins, conf);
            if (typeof ctx.stylexOptions.adapter === 'function') {
                const adapter = ctx.stylexOptions.adapter();
                if (!adapter.name) {
                    throw error('adapter missing name.');
                }
                adapter.setup(adapterContext, plugin);
            }
        };
    };
}

const defaultBabelConfig = {
    plugins: [],
    presets: []
};
const defaultOptions = {
    useCSSLayers: false,
    babelConfig: defaultBabelConfig,
    importSources: [
        'stylex',
        '@stylexjs/stylex'
    ],
    include: /\.(mjs|js|ts|vue|jsx|tsx)(\?.*|)$/,
    optimizedDeps: [],
    manuallyControlCssOrder: false,
    enableStylexExtend: false
};
function extend(ctx) {
    const filter = createFilter(/\.[jt]sx?$/, []);
    return {
        name: 'stylex-extend',
        buildStart () {
            ctx.globalStyles = {};
        },
        transform: {
            order: 'pre',
            async handler (code, id) {
                if (id.includes('/node_modules/')) return;
                if (!filter(id)) return;
                ctx.setupRollupPluginContext(this);
                const { original } = parseRequest(id);
                const parserOptions = [];
                if (!original.endsWith('.ts')) {
                    parserOptions.push('jsx');
                }
                if (/\.tsx?$/.test(original)) {
                    parserOptions.push('typescript');
                }
                const stmts = scanImportStmt(code, id, {
                    plugins: parserOptions
                });
                code = await ctx.rewriteImportStmts(code, original, stmts);
                const result = await transformStylexExtend(code, {
                    filename: original,
                    options: {
                        parserOptions,
                        opts: ctx.stylexExtendOptions
                    },
                    env: ctx.env
                });
                if (!result || !result.code) return;
                if (result.metadata && 'globalStyle' in result.metadata) {
                    ctx.globalStyles[original] = result.metadata.globalStyle;
                }
                return {
                    code: result.code,
                    map: result.map
                };
            }
        }
    };
}
function stylex(options = {}) {
    options = {
        ...defaultOptions,
        ...options
    };
    const c = createPluginContext(options);
    const plugin = {
        name: 'stylex',
        api: {
            ctx: c
        },
        buildStart () {
            if (this.meta.watchMode) {
                c.styleRules.clear();
            }
        },
        shouldTransformCachedModule ({ id, meta }) {
            if ('stylex' in meta && meta.stylex) {
                const { original } = parseRequest(id);
                c.styleRules.set(original, meta.stylex);
            }
            return false;
        },
        async transform (code, id) {
            c.setupRollupPluginContext(this);
            if (!c.skipResolve(code, id)) return;
            const { original } = parseRequest(id);
            code = await c.rewriteImportStmts(code, original);
            const result = await transformStylex(code, {
                filename: original,
                env: c.env,
                options: c.stylexOptions
            });
            if (!result || !result.code) return;
            if (result.metadata && 'stylex' in result.metadata) {
                const rules = result.metadata.stylex;
                if (rules.length) c.styleRules.set(original, rules);
            }
            return {
                code: result.code,
                map: result.map,
                meta: result.metadata
            };
        }
    };
    const server = createForViteServer(c, extend);
    server(plugin);
    return plugin;
}
stylex.getPluginAPI = (plugins)=>{
    var _plugins_find;
    return (_plugins_find = plugins.find((p)=>p.name === 'stylex')) === null || _plugins_find === void 0 ? void 0 : _plugins_find.api;
};
function adapter(plugin, options) {
    const { filename = 'stylex.css', ...rest } = options;
    const { api, ...hooks } = plugin(rest);
    const { ctx } = api;
    return {
        ...hooks,
        generateBundle () {
            this.emitFile({
                fileName: filename,
                source: ctx.produceCSS(),
                type: 'asset'
            });
        }
    };
}

export { adapter, stylex as default, stylex };
