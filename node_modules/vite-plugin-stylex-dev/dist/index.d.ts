import { FilterPattern, Plugin, HookHandler, ResolvedConfig } from 'vite';
import * as rollup from 'rollup';
import { Plugin as Plugin$1 } from 'rollup';
import { Rule, Options } from '@stylexjs/babel-plugin';
import * as _babel_core from '@babel/core';
import { PluginItem } from '@babel/core';
import { StylexExtendBabelPluginOptions } from '@stylex-extend/babel-plugin';

type Env = 'server' | 'build';
interface ImportSpecifier {
    n: string | undefined;
    s: number;
    e: number;
}
declare class PluginContext {
    #private;
    styleRules: Map<string, Rule[]>;
    globalStyles: Record<string, string>;
    root: string;
    constructor(options: StylexPluginOptions);
    get filter(): (id: string | unknown) => boolean;
    get stylexExtendOptions(): StylexExtendBabelPluginOptions;
    get stylexOptions(): {
        [x: string]: {};
        babelConfig?: {
            plugins?: Array<_babel_core.PluginItem>;
            presets?: Array<_babel_core.PluginItem>;
        };
        useCSSLayers?: boolean;
        include?: string | RegExp | readonly (string | RegExp)[] | undefined;
        exclude?: string | RegExp | readonly (string | RegExp)[] | undefined;
        optimizedDeps?: Array<string>;
        manuallyControlCssOrder?: boolean | ManuallyControlCssOrder;
        enableStylexExtend?: boolean | StylexExtendOptions;
        adapter?: () => AdapterConfig;
        importSources?: readonly (string | Readonly<{
            from: string;
            as: string;
        }>)[] | undefined;
        treeshakeCompensation?: boolean;
        genConditionalClasses?: boolean | undefined;
        unstable_moduleResolution?: Readonly<{
            type: "commonJS";
            rootDir: string;
            themeFileExtension?: null | undefined | string;
        }> | Readonly<{
            type: "haste";
            themeFileExtension?: null | undefined | string;
        }> | Readonly<{
            type: "experimental_crossFileParsing";
            rootDir: string;
            themeFileExtension?: null | undefined | string;
        }> | undefined;
        test?: boolean | undefined;
        useRemForFontSize?: boolean | undefined;
        classNamePrefix?: string | undefined;
        definedStylexCSSVariables?: {
            [key: string]: unknown;
        };
        styleResolution?: "application-order" | "property-specificity" | "legacy-expand-shorthands" | undefined;
    };
    setupRollupPluginContext(rollupPluginContext: RollupPluginContext): void;
    skipResolve(code: string, id: string): boolean;
    rewriteImportStmts(code: string, id: string, stmts?: ImportSpecifier[]): Promise<string>;
    produceCSS(input?: Map<string, Rule[]>): string;
    destory(): void;
    get env(): Env;
    set env(env: Env);
    get importSources(): readonly (string | Readonly<{
        from: string;
        as: string;
    }>)[];
    get stmts(): ImportSpecifier[];
    get rollupPluginContext(): rollup.TransformPluginContext | null;
    get controlCSSByManually(): ManuallyControlCssOrder;
    get isManuallyControlCSS(): boolean;
}
declare function createPluginContext(options: StylexPluginOptions): PluginContext;

type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
interface AdapterViteOptions {
    cssPlugins: Plugin[];
    config: ResolvedConfig;
}
interface AdapterContext {
    env: Env;
    vite: AdapterViteOptions;
    rules: PluginContext['styleRules'];
    useCSSLayers: boolean;
    produceCSS: (input?: Map<string, Rule[]>) => string;
    transform: HookHandler<Plugin['transform']>;
}
interface AdapterConfig {
    name: string;
    setup: (ctx: AdapterContext, plugin: Plugin) => void;
}
type Pretty<T> = {
    [key in keyof T]: T[key] extends (...args: any[]) => any ? (...args: Parameters<T[key]>) => ReturnType<T[key]> : T[key] & NonNullable<unknown>;
} & NonNullable<unknown>;
type InternalOptions = Mutable<Omit<Options, 'dev' | 'runtimeInjection' | 'aliases'>>;
type StylexOptions = Partial<Mutable<Options>>;
type StylexExtendOptions = Omit<StylexExtendBabelPluginOptions, 'unstable_moduleResolution' | 'classNamePrefix'>;
interface ManuallyControlCssOrder {
    id?: string;
    symbol?: string;
}
interface InternalStylexPluginOptions extends Partial<InternalOptions> {
    babelConfig?: {
        plugins?: Array<PluginItem>;
        presets?: Array<PluginItem>;
    };
    useCSSLayers?: boolean;
    include?: FilterPattern;
    exclude?: FilterPattern;
    /**
     * @experimental
     */
    optimizedDeps?: Array<string>;
    /**
     * @experimental
     */
    manuallyControlCssOrder?: boolean | ManuallyControlCssOrder;
    /**
     * @experimental
     */
    enableStylexExtend?: boolean | StylexExtendOptions;
    /**
     * @experimental
     */
    adapter?: () => AdapterConfig;
    [prop: string]: unknown;
}
type StylexPluginOptions = Pretty<InternalStylexPluginOptions>;
declare const transform: HookHandler<Plugin['transform']>;
type RollupPluginContext = ThisParameterType<typeof transform>;

type StylexPluginAPI = {
    ctx: ReturnType<typeof createPluginContext>;
};
declare function stylex(options?: StylexPluginOptions): Plugin<any>;
declare namespace stylex {
    var getPluginAPI: (plugins: readonly Plugin[]) => StylexPluginAPI;
}
type AdapterStylexPluginOptions = StylexPluginOptions & {
    filename: string;
};
declare function adapter(plugin: typeof stylex, options: AdapterStylexPluginOptions): Plugin$1;

export { type AdapterStylexPluginOptions, type StylexOptions, type StylexPluginAPI, type StylexPluginOptions, adapter, stylex as default, stylex };
