'use strict';

require('fs');
require('path');
require('@stylexjs/babel-plugin');
require('@rollup/pluginutils');
require('@babel/core');

function parseRequest(id) {
    const [original, kind] = id.split('?');
    if (!kind) return {
        original,
        kind: 'native'
    };
    return {
        original,
        kind
    };
}

const CONSTANTS = {
    WS_EVENT: 'stylex:hmr',
    VIRTUAL_STYLEX_ID: 'virtual:stylex.css',
    RESOLVED_ID_WITH_QUERY_REG: /[/\\]__stylex(_.*?)?\.css(\?.*)?$/,
    RESOLVED_ID_REG: /[/\\]__stylex(?:_(.*?))?\.css$/,
    VIRTUAL_ENTRY_ALIAS: [
        /^(?:virtual:)?stylex(?::(.+))?\.css(\?.*)?$/
    ],
    STYLEX_BUNDLE_MARK: '@stylex__bundle__marker;',
    HASH_LENGTH: 6,
    CSS_PLUGINS: [
        'vite:css',
        'vite:css-post'
    ],
    WELL_KNOW_LIBRARIES: [
        '@stylexjs/open-props'
    ]
};

const STYLEX_FOR_WAKU_MARKER = '/__stylex__waku.css';
const CLASSIC_WAKU_MARKER = '@stylex-dev.css';
const sharedRules = new Map();
// I would like know why can't sync the rules for sharedRules. It seems like got two instance of waku
function waku() {
    return {
        name: 'waku',
        setup (ctx, plugin) {
            if (ctx.env === 'build') return;
            // @ts-expect-error
            ctx.vite.config.plugins = ctx.vite.config.plugins.filter((p)=>p.name !== 'stylex:server');
            let viteDevServer = null;
            const entries = new Set();
            const effects = new Set();
            const invalidate = (ids)=>{
                for (const id of ids){
                    const mod = viteDevServer === null || viteDevServer === void 0 ? void 0 : viteDevServer.moduleGraph.getModuleById(id);
                    if (!mod) continue;
                    viteDevServer === null || viteDevServer === void 0 ? void 0 : viteDevServer.reloadModule(mod);
                }
            };
            const self = {
                configureServer (server) {
                    viteDevServer = server;
                    viteDevServer.watcher.on('unlink', (path)=>{
                        const { original } = parseRequest(path);
                        if (sharedRules.has(original)) {
                            sharedRules.delete(original);
                        // update hmr
                        }
                    });
                },
                load (id) {
                    // Idk why i can't set css rule. waku seems like split vite plugin and
                    // run in two instance? you can print the sharedRules and run example/waku
                    // you can get collection one is three the other one is two.
                    // CLASSIC_WAKU_MARKER is work for rsc. but we should take care for them.
                    if (id === STYLEX_FOR_WAKU_MARKER || id === CLASSIC_WAKU_MARKER) {
                        if (id === CLASSIC_WAKU_MARKER) {
                            entries.add(id);
                        }
                        return {
                            code: ctx.produceCSS(sharedRules),
                            map: {
                                mappings: ''
                            }
                        };
                    }
                },
                resolveId (id) {
                    if (id === CONSTANTS.VIRTUAL_STYLEX_ID) {
                        entries.add(STYLEX_FOR_WAKU_MARKER);
                        return STYLEX_FOR_WAKU_MARKER;
                    }
                },
                async transform (code, id, opt) {
                    var _ctx_transform;
                    const result = await ((_ctx_transform = ctx.transform) === null || _ctx_transform === void 0 ? void 0 : _ctx_transform.apply(this, [
                        code,
                        id,
                        opt
                    ]));
                    const { original } = parseRequest(id);
                    if (typeof result === 'object' && (result === null || result === void 0 ? void 0 : result.meta) && 'stylex' in result.meta) {
                        const rule = [];
                        if (result.meta.stylex.length > 0) {
                            rule.push(result.meta.stylex);
                        }
                        effects.add(original);
                        sharedRules.set(original, result.meta.stylex);
                        invalidate(new Set([
                            ...entries
                        ]));
                    }
                    return result;
                }
            };
            Object.assign(plugin, self);
        }
    };
}

exports.waku = waku;
