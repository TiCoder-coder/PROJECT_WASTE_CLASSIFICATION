import { types } from '@babel/core';
import { utils } from '@stylexjs/shared';
import { serialize, compile, stringify } from 'stylis';
import { createRequire } from 'module';
import path from 'path';


// -- Shims --
import cjsUrl from 'node:url';
import cjsPath from 'node:path';
import cjsModule from 'node:module';
const __filename = cjsUrl.fileURLToPath(import.meta.url);
const __dirname = cjsPath.dirname(__filename);
const require = cjsModule.createRequire(import.meta.url);
const ENABLED_PKGS = {
    stylex: '@stylexjs/stylex',
    extend: '@stylex-extend/core'
};
function handleImportStmt(stmts, callback) {
    for (const stmt of stmts){
        if (stmt.isImportDeclaration()) {
            const stop = callback(stmt);
            if (stop) break;
        }
    }
}

const MESSAGES = {
    NOT_IMPLEMENTED: 'Not implemented.',
    INVALID_CSS_AST_KIND: 'Only accept a style object.',
    NO_STATIC_ATTRIBUTE: 'Only static attribute is allowed in style object.',
    NO_NESTED_SPREAD: 'Nested spread syntax is not allowed in style object.',
    ONLY_LOGICAL_AND: 'Only logical and operator is allowed in spread element.',
    INVALID_SPREAD_SIDE: 'Only object expression is allowed on the right side of the spread element.',
    INVALID_ATTRS_KIND: "Only object expression is allowed for jsx attribute 'stylex'",
    INLINE_ONLY_ONE_ARGUMENT: 'function inline() only accept one argument.',
    GLOBAL_STYLE_ONLY_ONE_ARGUMENT: 'function injectGlobalStyle() only accept one argument.',
    IMPORT_EXTEND_PKG_ERROR: "'@stylex-extend/core' only support named import.",
    INVALID_FILE: 'Invalid file path',
    ONLY_TOP_LEVEL_INJECT_GLOBAL_STYLE: 'function injectGlobalStyle() must be called at the top level of the module.',
    INVALID_CSS_TOKEN: 'Invalid css token.'
};

function isStringLikeKind(path) {
    return path.isStringLiteral() || path.isIdentifier();
}
function isIdentifier(path) {
    return path.isIdentifier();
}
function getStringLikeKindValue(path) {
    if (!('node' in path)) {
        if (path.type === 'StringLiteral') return path.value;
        return path.name;
    }
    return getStringLikeKindValue(path.node);
}
function callExpression(callee, args) {
    return types.callExpression(callee, args);
}
function arrowFunctionExpression(params, body) {
    return types.arrowFunctionExpression(params, body);
}
function stringLiteral(value) {
    return types.stringLiteral(value);
}
function objectProperty(key, value) {
    return types.objectProperty(key, value);
}
function objectExpression(properties) {
    return types.objectExpression(properties);
}
function memberExpression(object, property, computed = false) {
    return types.memberExpression(object, property, computed);
}
function variableDeclaration(identifier, ast) {
    return types.variableDeclaration('const', [
        types.variableDeclarator(typeof identifier === 'string' ? types.identifier(identifier) : identifier, ast)
    ]);
}
function isObjectExpression(path) {
    return path.isObjectExpression();
}
function isObjectProperty(path) {
    return path.isObjectProperty();
}
function isSpreadElement(path) {
    return path.isSpreadElement();
}
function isMemberExpression(path) {
    return path.isMemberExpression();
}
function isTemplateLiteral(path) {
    return path.isTemplateLiteral();
}
function isTopLevelCalled(path) {
    return types.isProgram(path.parent) || types.isExportDefaultDeclaration(path.parent) || types.isExportNamedDeclaration(path.parent);
}
function isStmt(path) {
    return path.isStatement();
}
function is(condit, message = 'Invalid Error') {
    if (!condit) throw new Error(message);
}
function findNearestStatementAncestor(path) {
    if (isStmt(path)) return path;
    if (path.parentPath == null) {
        throw new Error('Unexpected Path found that is not part of the AST.');
    }
    return findNearestStatementAncestor(path.parentPath);
}

class Context {
    options;
    importIdentifiers;
    stmts;
    imports;
    filename;
    fileNamesForHashing;
    modules;
    constructor(){
        this.options = Object.create(null);
        this.importIdentifiers = Object.create(null);
        this.stmts = [];
        this.imports = new Map();
        this.filename = undefined;
        this.fileNamesForHashing = new Map();
        this.modules = [];
    }
    setupOptions(pluginOptions, identifiers, modules) {
        this.options = {
            ...this.options,
            ...pluginOptions
        };
        this.importIdentifiers = identifiers;
        this.modules = modules;
    }
    get attach() {
        const { helper } = this.options.stylex;
        if (helper in this.importIdentifiers) {
            return this.importIdentifiers[helper];
        }
        throw new Error(`[stylex-extend]: helper ${helper} is not imported`);
    }
    get enableStylex() {
        return !!this.options.stylex.helper;
    }
    get themeFileExtension() {
        return this.options.unstable_moduleResolution.themeFileExtension ?? '.stylex';
    }
    addImports(i, o) {
        this.imports.set(i, o);
    }
}

// evaluate css with JS AST
// There are three steps
// 1. Scan input JS AST and transform as css rules.
// 2. Compose css rules to a whole JS Object. At the same time, do generation optmization
// 3. Generate final JS AST (ensure node order)
// Mark is a collection that help us to define dynamic value in css object.
// All dynamic token should be consumed at transform as JS AST step.
const MARK = {
    reference: (s)=>'_#' + s,
    isReference: (s)=>s.startsWith('_#'),
    referenceSymbol: 'referenceName'
};
function capitalizeFirstLetter(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}
function hash(s) {
    return 'a' + utils.hash(s);
}
function union(...c) {
    // @ts-expect-error
    return new Set(c.reduce((acc, set)=>[
            ...acc,
            ...set
        ], []));
}
const handleObjectProperty = (key, value)=>{
    return objectProperty(stringLiteral(key), value);
};
function handleIdentifier(path) {
    if (!isIdentifier(path)) return;
    return {
        path,
        define: path.node.name
    };
}
function handleMemeberExpression(path) {
    if (!isMemberExpression(path)) return;
    const obj = path.get('object');
    const prop = path.get('property');
    if (isIdentifier(obj) && isStringLikeKind(prop)) {
        // Prevent the same name as identifier
        const define = getStringLikeKindValue(obj) + capitalizeFirstLetter(getStringLikeKindValue(prop));
        return {
            path,
            define: MARK.reference(define)
        };
    }
}
function handleCallExpression(path) {
    if (!path.isCallExpression()) return;
    const callee = path.get('callee');
    const result = handleIdentifier(callee) || handleMemeberExpression(callee);
    if (!result) return;
    return {
        define: MARK.isReference(result.define) ? result.define : MARK.reference(result.define),
        path
    };
}
function pickupDuplicateASTNode(paths) {
    const seen = new Map();
    for (const path of paths){
        const define = path.getData(MARK.referenceSymbol);
        if (define && !seen.has(define)) {
            seen.set(define, path);
        }
    }
    return seen;
}
function cleanupDuplicateASTNode(paths, sortBy = []) {
    const seen = pickupDuplicateASTNode(paths);
    return [
        ...seen.values()
    ].sort((a, b)=>{
        const sceneA = sortBy.indexOf(a.getData(MARK.referenceSymbol));
        const sceneB = sortBy.indexOf(b.getData(MARK.referenceSymbol));
        return sceneA - sceneB;
    }).map((p)=>p.node);
}
function ensureCSSValueASTKind(value) {
    let ast;
    switch(typeof value){
        case 'undefined':
            ast = types.identifier('undefined');
            break;
        case 'string':
            if (value === 'undefined') {
                ast = types.identifier('undefined');
            } else if (MARK.isReference(value)) {
                ast = types.identifier(value.slice(2));
            } else {
                ast = types.stringLiteral(value);
            }
            break;
        case 'object':
            ast = types.nullLiteral();
            break;
        case 'number':
            ast = types.numericLiteral(value);
    }
    return ast;
}
function convertCSSRuleToAST(rule) {
    const ast = [];
    for(const attr in rule){
        const value = rule[attr];
        if (typeof value === 'object' && value !== null) {
            const childAST = convertCSSRuleToAST(value);
            ast.push(handleObjectProperty(attr, childAST));
        } else {
            const v = ensureCSSValueASTKind(value);
            ast.push(handleObjectProperty(attr, v));
        }
    }
    return objectExpression(ast);
}
// recursion is expensive, so we have to be patient when recording css referenecs.
class CSSParser {
    jsAST;
    counter;
    rules;
    cssReferences;
    duplicateDeclaration;
    variable;
    constructor(jsAST){
        this.jsAST = jsAST;
        this.counter = 0;
        this.rules = [];
        this.cssReferences = new Map();
        this.duplicateDeclaration = new Set();
        this.variable = this.jsAST.scope.generateUidIdentifier('styles');
    }
    recordCSSReference(path, defineName) {
        let result = handleIdentifier(path) || handleMemeberExpression(path) || handleCallExpression(path);
        if (defineName && !result) result = {
            path,
            define: defineName
        };
        if (!result) return;
        path.setData(MARK.referenceSymbol, result.define);
        if (this.cssReferences.has(this.counter)) {
            const previous = this.cssReferences.get(this.counter);
            if (!this.duplicateDeclaration.has(result.define)) {
                this.cssReferences.set(this.counter, [
                    ...previous,
                    result.path
                ]);
                this.duplicateDeclaration.add(result.define);
            }
        } else {
            this.cssReferences.set(this.counter, [
                result.path
            ]);
            this.duplicateDeclaration.add(result.define);
        }
    }
    parseObjectProperty(path) {
        is(path.get('computed'), MESSAGES.NO_STATIC_ATTRIBUTE);
        const attribute = path.get('key');
        const valuePath = path.get('value');
        if (!isStringLikeKind(attribute)) throw new Error(MESSAGES.NO_STATIC_ATTRIBUTE);
        const { value } = path.node;
        const CSSObject = {};
        const attr = getStringLikeKindValue(attribute);
        let isReference = false;
        switch(value.type){
            case 'NullLiteral':
                CSSObject[attr] = null;
                break;
            case 'Identifier':
                if (value.name === 'undefined') CSSObject[attr] = undefined;
                else {
                    CSSObject[attr] = MARK.reference(value.name);
                    isReference = true;
                    this.recordCSSReference(valuePath);
                }
                break;
            case 'StringLiteral':
            case 'NumericLiteral':
                CSSObject[attr] = value.value;
                break;
            case 'TemplateLiteral':
            case 'ConditionalExpression':
                {
                    if (value.type === 'TemplateLiteral' && !value.expressions.length) {
                        CSSObject[attr] = value.quasis[0].value.raw;
                    } else {
                        const value = MARK.reference(hash(attr));
                        CSSObject[attr] = value;
                        isReference = true;
                        this.recordCSSReference(valuePath, value);
                    }
                    break;
                }
            case 'MemberExpression':
                {
                    if (!valuePath.isMemberExpression()) break;
                    const result = handleMemeberExpression(valuePath);
                    CSSObject[attr] = result.define;
                    isReference = true;
                    this.recordCSSReference(valuePath);
                    break;
                }
            case 'CallExpression':
                if (valuePath.isCallExpression()) {
                    const { define } = handleCallExpression(valuePath);
                    CSSObject[attr] = define;
                    isReference = true;
                    this.recordCSSReference(valuePath);
                }
                break;
            case 'ObjectExpression':
                {
                    if (isObjectExpression(valuePath)) {
                        let isReference = false;
                        for (const prop of valuePath.get('properties')){
                            is(!isSpreadElement(prop), MESSAGES.NO_NESTED_SPREAD);
                            if (isObjectProperty(prop)) {
                                const { rule, isReference: _isReference } = this.parseObjectProperty(prop);
                                if (_isReference) isReference = true;
                                Object.assign(CSSObject, rule);
                            }
                        }
                        return {
                            rule: {
                                [attr]: CSSObject
                            },
                            isReference,
                            isSpread: false
                        };
                    }
                }
        }
        return {
            rule: CSSObject,
            isReference,
            isSpread: false
        };
    }
    parseSpreadElement(path) {
        const arg = path.get('argument');
        if (isObjectExpression(arg)) {
            const CSSObject = {};
            let isReference = false;
            for (const prop of arg.get('properties')){
                is(!isSpreadElement(prop), MESSAGES.NO_NESTED_SPREAD);
                if (prop.isObjectProperty()) {
                    const { rule, isReference: _isReference } = this.parseObjectProperty(prop);
                    if (_isReference) isReference = true;
                    Object.assign(CSSObject, rule);
                }
            }
            return {
                rule: CSSObject,
                isReference,
                isSpread: false
            };
        }
        if (arg.isLogicalExpression()) {
            is(arg.node.operator === '&&', MESSAGES.ONLY_LOGICAL_AND);
            const right = arg.get('right');
            if (!isObjectExpression(right)) throw new Error(MESSAGES.INVALID_SPREAD_SIDE);
            const CSSObject = {};
            let isReference = false;
            for (const prop of right.get('properties')){
                is(!isSpreadElement(prop), MESSAGES.NO_NESTED_SPREAD);
                if (prop.isObjectProperty()) {
                    const { rule, isReference: _isReference } = this.parseObjectProperty(prop);
                    if (_isReference) isReference = true;
                    Object.assign(CSSObject, rule);
                }
            }
            this.recordCSSReference(arg.get('left'), hash(JSON.stringify(CSSObject)));
            return {
                rule: CSSObject,
                isReference,
                isSpread: true
            };
        }
        throw new Error(MESSAGES.NOT_IMPLEMENTED);
    }
    parse() {
        const properties = this.jsAST.get('properties');
        for(let i = 0; i < properties.length; i++){
            const path = properties[i];
            const rule = isObjectProperty(path) ? this.parseObjectProperty(path) : isSpreadElement(path) ? this.parseSpreadElement(path) : null;
            if (typeof rule === 'object' && rule) {
                this.rules.push({
                    ...rule,
                    vairableNames: union(this.duplicateDeclaration)
                });
            }
            if (isSpreadElement(path)) {
                this.duplicateDeclaration.clear();
            }
            this.counter++;
        }
    }
    toJSAST() {
        // 1. merge css
        // 2. evaluate css reference
        // 3. if reference is exists, hoist them and generate arrowFunction AST
        if (!this.rules.length) return;
        let step = 0;
        let section = 0;
        const mergedCSSRules = [];
        while(step < this.counter){
            const { rule, isReference, isSpread, vairableNames } = this.rules[step];
            const referencePaths = [];
            if (isSpread) section++;
            if (isReference || isSpread) {
                // pick up epxression
                if (this.cssReferences.has(step)) {
                    referencePaths.push(...this.cssReferences.get(step));
                }
            }
            if (!mergedCSSRules.length || section >= mergedCSSRules.length) {
                mergedCSSRules.push({
                    rule,
                    vairableNames,
                    referencePaths,
                    isSpread
                });
            } else {
                mergedCSSRules[section].rule = {
                    ...mergedCSSRules[section].rule,
                    ...rule
                };
                mergedCSSRules[section].vairableNames = union(mergedCSSRules[section].vairableNames, vairableNames);
                mergedCSSRules[section].referencePaths = [
                    ...mergedCSSRules[section].referencePaths,
                    ...referencePaths
                ];
                mergedCSSRules[section].isSpread = isSpread;
            }
            if (isSpread) section++;
            step++;
        }
        const propertyAST = [];
        const expressionAST = [];
        // Don't forget to handle reference
        for(let i = 0; i < mergedCSSRules.length; i++){
            const CSSRule = mergedCSSRules[i];
            const { rule, referencePaths, vairableNames, isSpread } = CSSRule;
            const jsAST = convertCSSRuleToAST(rule);
            const expression = memberExpression(this.variable, stringLiteral('#' + i), true);
            if (vairableNames.size) {
                const variables = [
                    ...vairableNames
                ];
                let condit = null;
                if (isSpread) {
                    variables.pop();
                    condit = referencePaths.pop();
                }
                const calleeArguments = cleanupDuplicateASTNode(referencePaths, variables);
                const callee = callExpression(expression, calleeArguments);
                if (condit) {
                    expressionAST.push(types.logicalExpression('&&', condit.node, variables.length ? callee : expression));
                } else {
                    expressionAST.push(callee);
                }
                if (variables.length) {
                    const fnAST = arrowFunctionExpression(variables.map((s)=>types.identifier(MARK.isReference(s) ? s.slice(2) : s)), jsAST);
                    propertyAST.push(handleObjectProperty('#' + i, fnAST));
                } else {
                    propertyAST.push(handleObjectProperty('#' + i, jsAST));
                }
                continue;
            }
            propertyAST.push(handleObjectProperty('#' + i, jsAST));
            expressionAST.push(expression);
        }
        return [
            objectExpression(propertyAST),
            this.variable,
            expressionAST,
            mergedCSSRules
        ];
    }
}
// Only expression nodes can be scanned.
function scanObjectExpression(path) {
    if (!isObjectExpression(path)) throw new Error(MESSAGES.INVALID_CSS_AST_KIND);
    const cssparser = new CSSParser(path);
    cssparser.parse();
    return cssparser.toJSAST();
}

const KEBACASE = /[A-Z]+(?![a-z])|[A-Z]/g;
function kebabCase(s) {
    return s.replace(KEBACASE, (_, ofs)=>(ofs ? '-' : '') + _.toLowerCase());
}
function getCSSVarName(themeName, key, classNamePrefix) {
    return `var(--${classNamePrefix + utils.hash(`${themeName}.${key}`)})`;
}
const hyphenateRegex = /[A-Z]|^ms/g;
function isCustomProperty(prop) {
    return prop.charCodeAt(1) === 45;
}
function processStyleName(prop) {
    return isCustomProperty(prop) ? prop : prop.replace(hyphenateRegex, '-$&').toLowerCase();
}
class Stringify {
    css;
    ctx;
    rules;
    constructor(rules, ctx){
        this.css = '';
        this.ctx = ctx;
        this.rules = rules;
        this.parse();
    }
    print(s) {
        this.css += s;
    }
    get classNamePrefix() {
        return this.ctx.options.classNamePrefix;
    }
    parse() {
        for (const rule of this.rules){
            const { referencePaths, rule: cssRule } = rule;
            const jsAST = pickupDuplicateASTNode(referencePaths);
            this.run(cssRule, jsAST);
        }
    }
    evaluateCSSVariableFromStylex(s, jsAST) {
        const spliter = (s)=>kebabCase(s.slice(2)).split('-');
        const getCssValue = (belong, attr)=>{
            if (this.ctx.fileNamesForHashing.has(belong)) {
                const { fileName, exportName } = this.ctx.fileNamesForHashing.get(belong);
                const themeName = utils.genFileBasedIdentifier({
                    fileName,
                    exportName
                });
                return getCSSVarName(themeName, attr, this.classNamePrefix);
            }
            return belong;
        };
        const [belong, attr] = spliter(s);
        if (!attr && jsAST.has(s)) {
            let css = '';
            const path = jsAST.get(s);
            if (!isTemplateLiteral(path)) throw new Error(MESSAGES.INVALID_CSS_TOKEN);
            const { quasis } = path.node;
            const expressions = path.get('expressions');
            let cap = expressions.length;
            css += quasis[0].value.raw;
            while(cap){
                const { define } = handleMemeberExpression(expressions.shift());
                const [belong, attr] = spliter(define);
                if (belong && attr) {
                    css += getCssValue(belong, attr);
                }
                cap--;
            }
            return css;
        }
        return getCssValue(belong, attr);
    }
    run(rule, jsAST) {
        if (Array.isArray(rule)) {
            for (const r of rule){
                this.run(r, jsAST);
            }
        } else {
            for(const selector in rule){
                const content = rule[selector];
                // In css only `null` and `undefined` are considered as falsy values
                if (typeof content === 'undefined' || typeof content === 'object' && !content) continue;
                if (typeof content === 'object') {
                    this.print(selector);
                    this.print('{');
                    this.run(content, jsAST);
                    this.print('}');
                } else {
                    this.print(processStyleName(selector));
                    this.print(':');
                    if (typeof content === 'string') {
                        let c = content;
                        if (MARK.isReference(c)) {
                            c = this.evaluateCSSVariableFromStylex(c, jsAST);
                        }
                        this.print(`${c}`);
                    } else {
                        this.print(content);
                    }
                    this.print(';');
                }
            }
        }
    }
}
function transformInjectGlobalStyle(path, ctx) {
    const args = path.get('arguments');
    if (args.length > 1) throw new Error(MESSAGES.GLOBAL_STYLE_ONLY_ONE_ARGUMENT);
    if (!args[0].isObjectExpression()) throw new Error(MESSAGES.INVALID_CSS_AST_KIND);
    const expression = args[0];
    const result = scanObjectExpression(expression);
    if (result) {
        // eslint-disable-next-line no-unused-vars
        const [_, __1, ___2, cssRules] = result;
        const sb = new Stringify(cssRules, ctx);
        const CSS = serialize(compile(sb.css), stringify);
        path.replaceWith(types.stringLiteral(''));
        return CSS;
    }
}

const EXTEND_INJECT_GLOBAL_STYLE = 'injectGlobalStyle';
const EXTEND_INLINE = 'inline';
const _require = createRequire(__filename);
// the order is same as stylexjs
const FILE_EXTENSIONS = [
    '.js',
    '.ts',
    '.tsx',
    '.jsx',
    '.mjs',
    '.cjs'
];
// Define a function to record css variable file
function createCSSVariableMatchers(extendSuffix = '', ...suffixs) {
    const merged = [
        ...FILE_EXTENSIONS,
        ...suffixs
    ].map((s)=>s !== extendSuffix ? extendSuffix + s : s);
    return (filename)=>{
        for (const ext of merged){
            if (filename.endsWith(ext)) return true;
        }
    };
}
function resolvePathAliases(path, aliases) {
    const result = [
        path
    ];
    if (aliases == null || Object.keys(aliases).length === 0) {
        return result;
    }
    for (const [alias, _value] of Object.entries(aliases)){
        const value = Array.isArray(_value) ? _value : [
            _value
        ];
        if (alias.includes('*')) {
            const [before, after] = alias.split('*');
            if (path.startsWith(before) && path.endsWith(after)) {
                const replacementString = path.slice(before.length, after.length > 0 ? -after.length : undefined);
                value.forEach((v)=>{
                    result.push(v.split('*').join(replacementString));
                });
            }
        } else if (alias === path) {
            value.forEach((v)=>{
                result.push(v);
            });
        }
    }
    return result;
}
function resolveRelativePath(relativePath, ctx) {
    if (!ctx.filename) throw new Error(MESSAGES.INVALID_FILE);
    let filePath = '';
    for (const ext of [
        '',
        ...FILE_EXTENSIONS
    ]){
        const relativePathWithExtension = relativePath + ext;
        if (relativePathWithExtension.startsWith('.')) {
            try {
                filePath = _require.resolve(relativePathWithExtension, {
                    paths: [
                        path.dirname(ctx.filename)
                    ]
                });
                break;
            } catch  {
                continue;
            }
        }
        const aliases = resolvePathAliases(relativePathWithExtension, ctx.options.aliases);
        for (const possiblePath of aliases){
            try {
                filePath = require.resolve(possiblePath, {
                    paths: [
                        path.dirname(ctx.filename)
                    ]
                });
                break;
            } catch  {}
        }
    }
    if (!filePath) throw new Error(MESSAGES.INVALID_FILE);
    switch(ctx.options.unstable_moduleResolution.type){
        case 'commonJS':
            return [
                filePath,
                path.resolve(ctx.options.unstable_moduleResolution.rootDir, filePath)
            ];
        case 'haste':
        case 'experimental_crossFileParsing':
            return [
                filePath,
                filePath
            ];
    }
}
function scanImportStmt(stmts, ctx) {
    const matchers = createCSSVariableMatchers(ctx.themeFileExtension, ctx.themeFileExtension);
    const relativeCSSPaths = new Map();
    handleImportStmt(stmts, (path)=>{
        const importSource = getStringLikeKindValue(path.get('source'));
        if (matchers(importSource)) {
            if (!relativeCSSPaths.has(importSource)) {
                relativeCSSPaths.set(importSource, []);
            }
            for (const spec of path.node.specifiers){
                // TODO: handle other import types
                if (types.isImportSpecifier(spec)) {
                    // using imported can sync the hash with stylexjs
                    relativeCSSPaths.get(importSource).push(getStringLikeKindValue(spec.imported));
                }
            }
        }
        if (importSource === ENABLED_PKGS.extend) {
            for (const spec of path.node.specifiers){
                // TODO: handle other import types
                if (types.isImportSpecifier(spec)) {
                    ctx.addImports(getStringLikeKindValue(spec.local), getStringLikeKindValue(spec.imported));
                }
            }
        }
    });
    relativeCSSPaths.forEach((specs, importSource)=>{
        // eslint-disable-next-line no-unused-vars
        const [_, fileName] = resolveRelativePath(importSource, ctx);
        for (const spec of specs){
            ctx.fileNamesForHashing.set(spec, {
                fileName,
                exportName: spec
            });
        }
    });
}

// inline is same as stylex macros
function pickupAllInlineMacro(args, ctx) {
    const result = [];
    for (const arg of args){
        if (arg.isCallExpression()) {
            const callee = arg.get('callee');
            if (callee.isIdentifier() && ctx.imports.has(callee.node.name)) {
                result.push(arg);
            }
        }
    }
    return result;
}
function transformInline(path, ctx) {
    const args = path.get('arguments');
    const inlineCalles = pickupAllInlineMacro(args, ctx);
    const expressions = [];
    for (const inlineCall of inlineCalles){
        const calleeArgs = inlineCall.get('arguments');
        if (calleeArgs.length > 1) throw new Error(MESSAGES.INLINE_ONLY_ONE_ARGUMENT);
        const expression = calleeArgs[0];
        if (expression.isObjectExpression()) {
            const result = scanObjectExpression(expression);
            if (result) {
                const [CSSAST, variable, expr] = result;
                const stylexDeclaration = variableDeclaration(variable, callExpression(ctx.importIdentifiers.create, [
                    CSSAST
                ]));
                ctx.stmts.push(stylexDeclaration);
                expressions.push(expr);
            }
        }
    }
    const finallExpression = [];
    for(let i = 0; i < args.length; i++){
        const path = args[i];
        if (!path.isCallExpression()) {
            finallExpression.push(path.node);
        } else {
            const callee = path.get('callee');
            if (callee.isIdentifier() && ctx.imports.get(callee.node.name) === EXTEND_INLINE) {
                finallExpression.push(...expressions.shift() ?? []);
            } else {
                finallExpression.push(path.node);
            }
        }
    }
    const nextCallExpression = callExpression(path.node.callee, finallExpression);
    path.replaceWith(nextCallExpression);
}

function transformStylexAttrs(path, ctx) {
    const value = path.get('value');
    if (!value.isJSXExpressionContainer()) return;
    const { importIdentifiers, attach } = ctx;
    const expression = value.get('expression');
    if (!expression.isObjectExpression()) throw new Error(MESSAGES.INVALID_ATTRS_KIND);
    const result = scanObjectExpression(expression);
    if (result) {
        const [CSSAST, variable, expr] = result;
        const stylexDeclaration = variableDeclaration(variable, callExpression(importIdentifiers.create, [
            CSSAST
        ]));
        ctx.stmts.push(stylexDeclaration);
        path.replaceWith(types.jsxSpreadAttribute(callExpression(attach, expr)));
    }
}

const JSX_ATTRIBUTE_NAME = 'stylex';
const defaultOptions = {
    stylex: {
        helper: 'props'
    },
    enableInjectGlobalStyle: true,
    classNamePrefix: 'x',
    unstable_moduleResolution: {
        type: 'commonJS',
        rootDir: process.cwd(),
        themeFileExtension: '.stylex'
    },
    aliases: {}
};
function ensureWithExtendPkg(stmts) {
    let enable = false;
    handleImportStmt(stmts, (path)=>{
        if (path.node.source.value === ENABLED_PKGS.extend) {
            enable = true;
            return true;
        }
    });
    return enable;
}
function declare() {
    const ctx = new Context();
    return {
        name: '@stylex-extend',
        manipulateOptions (_, parserOpts) {
            // https://babeljs.io/docs/babel-plugin-syntax-jsx
            // https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-typescript/src/index.ts
            const { plugins } = parserOpts;
            if (plugins.some((p)=>{
                const plugin = Array.isArray(p) ? p[0] : p;
                return plugin === 'typescript' || plugin === 'jsx';
            })) {
                return;
            }
            plugins.push('jsx');
        },
        visitor: {
            Program: {
                enter (path, state) {
                    const pluginOptions = {
                        ...defaultOptions,
                        ...state.opts
                    };
                    if (typeof pluginOptions.stylex === 'boolean') {
                        pluginOptions.stylex = {
                            helper: pluginOptions.stylex ? 'props' : ''
                        };
                    }
                    ctx.filename = state.filename || (state.file.opts?.sourceFileName ?? undefined);
                    const body = path.get('body');
                    if (pluginOptions.stylex.helper) {
                        const modules = [
                            'create',
                            pluginOptions.stylex.helper
                        ];
                        const identifiers = modules.reduce((acc, cur)=>({
                                ...acc,
                                [cur]: path.scope.generateUidIdentifier(cur)
                            }), {});
                        ctx.setupOptions(pluginOptions, identifiers, modules);
                    }
                    if (ensureWithExtendPkg(body)) {
                        scanImportStmt(body, ctx);
                        if (ctx.options.enableInjectGlobalStyle) {
                            path.traverse({
                                CallExpression (path) {
                                    const callee = path.get('callee');
                                    if (isIdentifier(callee)) {
                                        const identifier = getStringLikeKindValue(callee);
                                        if (ctx.imports.get(identifier) === EXTEND_INJECT_GLOBAL_STYLE) {
                                            const nearestStmt = findNearestStatementAncestor(path);
                                            if (!isTopLevelCalled(nearestStmt)) {
                                                throw new Error(MESSAGES.ONLY_TOP_LEVEL_INJECT_GLOBAL_STYLE);
                                            }
                                            const CSS = transformInjectGlobalStyle(path, ctx);
                                            if (CSS) {
                                                Reflect.set(state.file.metadata, 'globalStyle', CSS);
                                            }
                                        }
                                    }
                                }
                            });
                        }
                        path.traverse({
                            CallExpression (path) {
                                const { arguments: args } = path.node;
                                if (!args.length) return;
                                const maybeHave = args.find((a)=>a.type === 'CallExpression' && a.callee.type === 'Identifier' && ctx.imports.get(getStringLikeKindValue(a.callee)) === EXTEND_INLINE);
                                if (!maybeHave) return;
                                transformInline(path, ctx);
                                path.skip();
                            }
                        });
                    }
                },
                exit (path) {
                    const body = path.get('body');
                    handleImportStmt(body, (path)=>{
                        if (getStringLikeKindValue(path.get('source')) === ENABLED_PKGS.extend) {
                            path.remove();
                        }
                    });
                    if (ctx.stmts.length) {
                        const { importIdentifiers: identifiers, modules } = ctx;
                        const importSpecs = Object.values(identifiers).map((a, i)=>types.importSpecifier(a, types.identifier(modules[i])));
                        const importStmt = types.importDeclaration(importSpecs, types.stringLiteral('@stylexjs/stylex'));
                        path.unshiftContainer('body', ctx.stmts);
                        path.unshiftContainer('body', importStmt);
                    }
                    ctx.stmts = [];
                }
            },
            JSXAttribute (path) {
                if (path.node.name.name !== JSX_ATTRIBUTE_NAME || !ctx.enableStylex) return;
                transformStylexAttrs(path, ctx);
            }
        }
    };
}
function withOptions(options) {
    return [
        declare,
        options
    ];
}
declare.withOptions = withOptions;

export { declare as default };
